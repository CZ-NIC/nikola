#!/usr/bin/python
#
# Nikola - firewall log sender (a part of www.turris.cz project)
# Copyright (C) 2013 CZ.NIC, z.s.p.o. (http://www.nic.cz/)
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software Foundation,
# Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301  USA
#


import base64
import json
import optparse
import os
import random
import subprocess
import sys
import time
import traceback
import zlib
import socket

from nikola.filter import filter_records
from nikola.logger import get_logger
from nikola.rpc_wrapper import WrappedServer
from nikola.syslog_parser import parse_syslog
from nikola.rule_tester import test_connect, publish_result


if __name__ == '__main__':

    # Parse the command line options
    optparser = optparse.OptionParser("usage: %prog [options] server_addr")
    optparser.add_option("-l", "--log-file", dest='syslog_file',
                         default='/var/log/iptables', type='string',
                         help='specify the syslog file to be parsed')

    optparser.add_option("-m", "--max", dest='max', default=1000, type='int',
                         help='max record count to be sent')

    optparser.add_option("-f", "--date-format", dest='date_format',
                         default='%Y-%m-%dT%H:%M:%S', type='string',
                         help='specify the syslog date format')

    optparser.add_option("-r", "--log-rotate-conf", dest='logrotate_conf',
                         default='/etc/logrotate.d/iptables', type='string',
                         help='specify the log rotate config to be triggered')

    optparser.add_option("-d", "--debug", dest='debug', action='store_true',
                         default=False, help='use debug output')

    optparser.add_option("-w", "--wan-interface", dest='wan',
                         default=None, type='string',
                         help='specify the wan interface')

    optparser.add_option("-t", "--test-ip", dest='test_ip',
                         default='192.0.2.84', type='string',
                         help='the address which is used for rule testing purposes')

    optparser.add_option("-u", "--test-ruleid", dest='test_rule_id',
                         default='00DEB060', type='string',
                         help='this rule id is used for a testing purposes')

    optparser.add_option("-c", "--server-certificate", dest='certificate',
                         default='/etc/ssl/api.turris.pem', type='string',
                         help='server certificate to check')

    optparser.add_option("-i", "--ignore-certificate", dest='ignore_certificate',
                         action='store_true', default=False,
                         help='don\'t check the server certificate')

    optparser.add_option("-n", "--now", dest='now',
                         action='store_true', default=False,
                         help='don\'t use random sleep interval')

    (options, args) = optparser.parse_args()

    if len(args) != 1:
        optparser.error("incorrect number of arguments")

    logger = get_logger(options.debug)
    parsed = []

    server_addr = args[0]
    syslog_file = options.syslog_file
    max_packet_count = options.max
    syslog_date_format = options.date_format
    logrotate_conf = options.logrotate_conf
    wan = options.wan
    certificate = options.certificate
    ignore_certificate = options.ignore_certificate
    now = options.now
    test_ip = options.test_ip
    test_rule_id = options.test_rule_id

    logger.debug("Nikola synchronization is starting...")

    if not now:
        # sleep for random amount of time up to one minute
        seconds = random.randrange(60)
        logger.debug("Sleeping for %d seconds." % seconds)
        time.sleep(seconds)

    try:

        server = WrappedServer(server_addr)

        # Skip the certificate validation when the flag is checked
        if not ignore_certificate:

            # Validate the server certificate
            with open(certificate) as f:
                certificate = f.read()

            server.check_certificate(certificate)

        if not wan:

            # Get the wan interface using uci
            try:
                # by reading newtork conf
                wan = subprocess.check_output(('uci', 'get', 'network.wan.ifname')).strip()
            except (subprocess.CalledProcessError, OSError):
                try:
                    # by reading ucollect conf
                    wan = subprocess.check_output(('uci', 'get',
                                                   'ucollect.@interface[0].ifname')).strip()
                except (subprocess.CalledProcessError, OSError):
                    wan = None
                    logger.warning('Could not recognize wan device!')

        if os.path.exists(syslog_file) and wan:
            # Parse syslog
            parsed = parse_syslog(syslog_file, wan, syslog_date_format)

            # logrotete the logs
            output = subprocess.check_output(
                ('/usr/sbin/logrotate', '-s', '/tmp/logrotate-nikola.state', logrotate_conf, )
            )
            logger.debug(("logrotate output: %s" % output))

        else:
            # To file to parse means no records
            parsed = []

        init_res = server.init_session()
        logger.debug(init_res)

        exclude_regexps = init_res.get('fw_exclude_regexp', [])

        logger.info(("Records parsed: %d" % len(parsed)))
        parsed = filter_records(parsed, max_packet_count, exclude_regexps)
        logger.info(("Records after filtering: %d" % len(parsed)))

        logger.debug(("First record: %s" % parsed[0]) if parsed else 'No records')
        if max_packet_count < len(parsed):
            msg = "Too many records to send in one batch. (%d/%d)" % (len(parsed),
                                                                      max_packet_count)
            logger.error(msg)
            logger.debug(server.api_turris_cz.report_error(msg))
        else:
            # comporess the logs
            compressed = base64.b64encode(zlib.compress(json.dumps(parsed), 1))
            logger.info(server.api_turris_cz.firewall.store_logs(compressed))

    except socket.error, e:
        logger.error("socket: %s" % e)
    except Exception, e:
        logger.error("Exception thrown: %s" % e)
        e_type, e_value, e_traceback = sys.exc_info()
        logger.error("Exception traceback: %s" % str(traceback.extract_tb(e_traceback)))

    # publish whether the rules are applied
    try:
        publish_result(parsed, test_rule_id)
    except Exception, e:
        e_type, e_value, e_traceback = sys.exc_info()
        logger.error("error during rule test: %s" % e)
        e_type, e_value, e_traceback = sys.exc_info()
        logger.error("Exception traceback: %s" % str(traceback.extract_tb(e_traceback)))

    # try to send the testing packet
    try:
        test_connect(test_ip)
        logger.error("turris firewall rules might not be active")
    except socket.error, e:
        # sending should failed when the rules are applied
        pass
    except Exception, e:
        logger.error("failed to send the testing packet: %s" % e)
        e_type, e_value, e_traceback = sys.exc_info()
        logger.error("Exception traceback: %s" % str(traceback.extract_tb(e_traceback)))
